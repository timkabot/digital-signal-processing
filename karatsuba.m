clear;clc;function retval = multiply(x, y)  n = size(x)(2);  if size(y)(2) > n    n = size(y)(2);  endif    pow = 1;  while (n > pow)    pow = pow * 2;  endwhile  n = pow;  x = [zeros(1, n-size(x)(2)) x];  y = [zeros(1, n-size(y)(2)) y];    if (n == 1)    retval = x(1) * y(1);  else    m = idivide(n, 2, "fix");    x_l = x(1:m);    x_r = x(m+1:end);    y_l = y(1:m);    y_r = y(m+1:end);        array2num = @(x) sum(10.^(length(x)-1:-1:0) .* x);    num2array = @(x) str2num(num2str(x)')';        sum1 = num2array(array2num(x_l) + array2num(x_r));    sum2 = num2array(array2num(y_l) + array2num(y_r));        pr1 = multiply(x_l,y_l);    pr2 = multiply(x_r,y_r);    pr3 = multiply(sum1, sum2);    retval = pr1 * 10 ** n + (pr3 - pr1 - pr2) * 10 ** m + pr2;  endifendfunctionfunction retval = karatsuba_conv(x, y)  num2array = @(x) str2num(num2str(x)')';  x_size = size(x)(1);  y_size = size(y)(1);  n = x_size + y_size - 1  c = zeros(1, n);  for i = 1:x_size    for j = 1:y_size      x_ar = num2array(x(i));      y_ar = num2array(y(j));      c(i + j - 1) = c(i + j -1) + multiply(x_ar, y_ar);    endfor  endfor  retval = c;
endfunction
function retval = myconv(x, y)  num2array = @(x) str2num(num2str(x)')';  x_size = size(x)(1);  y_size = size(y)(1);  n = x_size + y_size - 1  c = zeros(1, n);  for i = 1:x_size    for j = 1:y_size      c(i + j - 1) = c(i + j -1) + x(i) * y(j);    endfor  endfor  retval = c;endfunctionx = [1, 2, 3, 4, 5, 6, 7, 8];y = [1, 2, 3];disp(karatsuba_conv(transpose(x),transpose(y)));disp(myconv(transpose(x), transpose(y)));disp(conv(x,y));arch_sample = audioread('arch_duke.wav');arch_sample = ((arch_sample(:,1) + arch_sample(:,2))/2)(1:100) + 10000000000000000000;hall_sample = audioread('large_hall.wav');hall_sample = ((hall_sample(:,1) + hall_sample(:,2))/2)(1:100) + 10000000000000000000;size(arch_sample);size(hall_sample);t=cputime;m_conv = karatsuba_conv(arch_sample, hall_sample);printf('Convolution with Karasuba multiplication takes %f seconds \n', cputime-t);t=cputime;m_conv = myconv(arch_sample, hall_sample);printf('Convolution with original multiplication takes %f seconds \n', cputime-t);t=cputime;o_conv = conv(arch_sample, hall_sample);printf('Convolution takes %f seconds \n', cputime - t);f_conf = fftconv(arch_sample, hall_sample);printf('Convolution with fast Fouries transform takes %f seconds \n', cputime - t);% Karatsuba shows the worst results because multiplication of 2 numbers lesser than 2^128 works quicker% due to low-level optimizations. Multiplication of bigger number require long arithmetic, the multiplication% in this case will take n^2 time, meanwhile Karatsuba method takes 2^log_2(3).% Also, operations with array and allocation in the Karatsuba method take a lot of CPU time.